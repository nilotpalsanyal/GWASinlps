if(prior == "mom")
{
bb = modelSelection( y = Surv(y, event), x = cbind(x[, names_xx_input, drop=F],x0), family="normal", priorCoef = momprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0))[ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "imom")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = imomprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "emom")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = emomprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "zellner")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = zellnerprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
# emom not yet implemented in modelSelection. Also, emomLM won't run with only one x variable.
#
#
if(verbose) cat( "selected :", hppm[[i]], "\n")  # print the HPPM vars
}
}
names_xx_not_selected = setdiff1(names_xx_input_set, unlist(hppm) )
return( list( hppm = unlist(hppm), not.selected = names_xx_not_selected ) )
}
mom = GWASinlps1( y, event, x, family="survival", prior="mom", tau=0.192, priorDelta = modelbbprior(1,1), k0=1, m=50, rxx=0.2, nskip=3, niter=2000, verbose=T, seed=1 )$selected
GWASinlps1 = function( y, event, x, family=c("normal","binomial","survival"), method=c("rigorous","quick"), cor_xy=NULL, mmle_xy=NULL, mu_xy=NULL, prior=c("mom", "imom", "emom", "zellner", "horseshoe"), tau, priorDelta = modelbbprior(1,1), k0, m, rxx, nskip = 3, niter = 2000, verbose = FALSE, seed = NULL, tau.hs.method = "halfCauchy", sigma.hs.method = "Jeffreys" )
{
if(family == "survival")
{
if(!exists("time", mode="integer")) time = Sys.time()
if(!is.null(seed)) set.seed(seed)
# Compute marginal utility if not provided
dat = data.frame(time=y,event=event,x)
if(is.null(mu_xy))
{
mu_xy = c()
for(j in 1:ncol(x)) mu_xy[j] = survreg( formula = as.formula(paste0("Surv(time,event) ~ x",j)), data=dat )$loglik[2]
}
names(mu_xy) = colnames(x)
# Run GWASinlps iteration
varsleft = colnames(x)
selected_iterwise = list()
max_nocollect = 0   # number of times no variables show up in the hppm
iter = 0
lastcollect = ""
while(looprun(lastcollect,varsleft,max_nocollect,m,nskip))
{
# enter ith iteration
iter = iter + 1
if(verbose) cat( "-------------", "\n", "Iteration ", iter, "\n", "-------------", "\n", sep = "")
# run nlpsAFTM
run = nlpsAFTM1( y = log(y), event = event, x = x[ , c(lastcollect[-1],varsleft)], x0 = x[,lastcollect[-1],drop=F], mu_xy=mu_xy, prior = prior, tau = tau, k0 = k0, rxx = rxx, verbose = verbose )
lastcollect = c("",run$hppm)
# add the selected vars to final output & regress them out. if no var is selected, note the instance.
if(length(lastcollect[-1]) > 0)
{
selected_iterwise = c(selected_iterwise, list(lastcollect[-1]))
# varsselected = c(varsselected, lastcollect)  # include HPPM vars in selected set
} else
{
selected_iterwise = c(selected_iterwise, '')
max_nocollect = max_nocollect + 1
if(verbose) {cat("***","nskip=",max_nocollect,"***","\n")}
if(max_nocollect==nskip) break
}
# exclude unselected vars from further consideration
# remove = run$not.selected
# varsleft = setdiff1( varsleft, c(lastcollect,remove) )
varsleft = setdiff1( varsleft, lastcollect[-1] )
# compute conditional utilities (with previously selected vars in model) for the rest of the vars
mu_xy = c()
for(j in 1:length(varsleft)) mu_xy[j] = survreg( formula = as.formula(paste0("Surv(time,event) ~ ", paste0(lastcollect[-1],collapse="+"), "+", varsleft[j])), data=dat )$loglik[2]
mu_xy[mu_xy>0] = min(mu_xy)
names(mu_xy) = varsleft
}
# Final output vars
varsfinal = varsselected[ 2 : min(length(varsselected),m) ]
# Print result
cat("=================================", "\n","Number of selected variables: ", length(varsfinal), "\n", "Time taken: ", round(difftime(Sys.time(), time, units = "mins"),2), " min", "\n",  "=================================", "\n", sep = "")
# Return
return( list(selected=varsfinal, selected_iterwise=selected_iterwise) )
}
}
nlpsAFTM1 = function( y, event, x, x0, mu_xy, prior = c("mom", "imom", "zellner"), tau, priorDelta = modelbbprior(1,1), k0, rxx, niter = 2000, verbose = F )
{
k0 = min(k0,ncol(x)) #if x has only 1 snp, but k0=2, then just reset k0=1
names_sorted_mu_xy = names( sort( mu_xy, decreasing = T ) [1:k0] )  # find x's with top k0 cors
hppm = list()
names_xx_input_set = NULL
for(i in 1:k0)  #take the i'th of top k0 x's
{
corr_xx = c(abs( arma_cor(x, x[,names_sorted_mu_xy[i]]) ))   # find cor of all x vars with xi and give names
names(corr_xx) = colnames(x)
names_xx_thres = na.omit( names(corr_xx[which(corr_xx >= rxx)]) ) # take x's with corr > rxx with xi
names_xx_input =  setdiff1(names_xx_thres, unlist(hppm))  # exclude x's previously chosen in hppm and set the rest as the input x's
names_xx_input_set = c( names_xx_input_set, names_xx_input )  # store the input x's
if(verbose) cat( "j =",i, "\ninput :", c(names_xx_input,colnames(x0)), "\n" )
if(length(names_xx_input) != 0  )  # if there is some input x
{
if(prior == "mom")
{
bb = modelSelection( y = Surv(y, event), x = cbind(x[, names_xx_input, drop=F],x0), family="normal", priorCoef = momprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=verbose )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0))[ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "imom")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = imomprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=verbose )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "emom")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = emomprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=verbose )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "zellner")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = zellnerprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=verbose )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
# emom not yet implemented in modelSelection. Also, emomLM won't run with only one x variable.
#
#
if(verbose) cat( "selected :", hppm[[i]], "\n")  # print the HPPM vars
}
}
names_xx_not_selected = setdiff1(names_xx_input_set, unlist(hppm) )
return( list( hppm = unlist(hppm), not.selected = names_xx_not_selected ) )
}
mom = GWASinlps1( y, event, x, family="survival", prior="mom", tau=0.192, priorDelta = modelbbprior(1,1), k0=1, m=50, rxx=0.2, nskip=3, niter=2000, verbose=T, seed=1 )$selected
GWASinlps1 = function( y, event, x, family=c("normal","binomial","survival"), method=c("rigorous","quick"), cor_xy=NULL, mmle_xy=NULL, mu_xy=NULL, prior=c("mom", "imom", "emom", "zellner", "horseshoe"), tau, priorDelta = modelbbprior(1,1), k0, m, rxx, nskip = 3, niter = 2000, verbose = FALSE, seed = NULL, tau.hs.method = "halfCauchy", sigma.hs.method = "Jeffreys" )
{
if(family == "survival")
{
if(!exists("time", mode="integer")) time = Sys.time()
if(!is.null(seed)) set.seed(seed)
# Compute marginal utility if not provided
dat = data.frame(time=y,event=event,x)
if(is.null(mu_xy))
{
mu_xy = c()
for(j in 1:ncol(x)) mu_xy[j] = survreg( formula = as.formula(paste0("Surv(time,event) ~ x",j)), data=dat )$loglik[2]
}
names(mu_xy) = colnames(x)
# Run GWASinlps iteration
varsleft = colnames(x)
selected_iterwise = list()
max_nocollect = 0   # number of times no variables show up in the hppm
iter = 0
lastcollect = ""
while(looprun(lastcollect,varsleft,max_nocollect,m,nskip))
{
# enter ith iteration
iter = iter + 1
if(verbose) cat( "-------------", "\n", "Iteration ", iter, "\n", "-------------", "\n", sep = "")
# run nlpsAFTM
run = nlpsAFTM1( y = log(y), event = event, x = x[ , c(lastcollect[-1],varsleft)], x0 = x[,lastcollect[-1],drop=F], mu_xy=mu_xy, prior = prior, tau = tau, k0 = k0, rxx = rxx, verbose = verbose )
lastcollect = c("",run$hppm)
# add the selected vars to final output & regress them out. if no var is selected, note the instance.
if(length(lastcollect[-1]) > 0)
{
selected_iterwise = c(selected_iterwise, list(lastcollect[-1]))
# varsselected = c(varsselected, lastcollect)  # include HPPM vars in selected set
} else
{
selected_iterwise = c(selected_iterwise, '')
max_nocollect = max_nocollect + 1
if(verbose) {cat("***","nskip=",max_nocollect,"***","\n")}
if(max_nocollect==nskip) break
}
# exclude unselected vars from further consideration
# remove = run$not.selected
# varsleft = setdiff1( varsleft, c(lastcollect,remove) )
varsleft = setdiff1( varsleft, lastcollect[-1] )
# compute conditional utilities (with previously selected vars in model) for the rest of the vars
mu_xy = c()
for(j in 1:length(varsleft)) mu_xy[j] = survreg( formula = as.formula(paste0("Surv(time,event) ~ ", paste0(lastcollect[-1],collapse="+"), "+", varsleft[j])), data=dat )$loglik[2]
mu_xy[mu_xy>0] = min(mu_xy)
names(mu_xy) = varsleft
}
# Final output vars
varsfinal = varsselected[ 2 : min(length(varsselected),m) ]
# Print result
cat("=================================", "\n","Number of selected variables: ", length(varsfinal), "\n", "Time taken: ", round(difftime(Sys.time(), time, units = "mins"),2), " min", "\n",  "=================================", "\n", sep = "")
# Return
return( list(selected=varsfinal, selected_iterwise=selected_iterwise) )
}
}
nlpsAFTM1 = function( y, event, x, x0, mu_xy, prior = c("mom", "imom", "zellner"), tau, priorDelta = modelbbprior(1,1), k0, rxx, niter = 2000, verbose = FALSE )
{
k0 = min(k0,ncol(x)) #if x has only 1 snp, but k0=2, then just reset k0=1
names_sorted_mu_xy = names( sort( mu_xy, decreasing = T ) [1:k0] )  # find x's with top k0 cors
hppm = list()
names_xx_input_set = NULL
for(i in 1:k0)  #take the i'th of top k0 x's
{
corr_xx = c(abs( arma_cor(x, x[,names_sorted_mu_xy[i]]) ))   # find cor of all x vars with xi and give names
names(corr_xx) = colnames(x)
names_xx_thres = na.omit( names(corr_xx[which(corr_xx >= rxx)]) ) # take x's with corr > rxx with xi
names_xx_input =  setdiff1(names_xx_thres, unlist(hppm))  # exclude x's previously chosen in hppm and set the rest as the input x's
names_xx_input_set = c( names_xx_input_set, names_xx_input )  # store the input x's
if(verbose) cat( "j =",i, "\ninput :", c(names_xx_input,colnames(x0)), "\n" )
if(length(names_xx_input) != 0  )  # if there is some input x
{
if(prior == "mom")
{
bb = modelSelection( y = Surv(y, event), x = cbind(x[, names_xx_input, drop=F],x0), family="normal", priorCoef = momprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0))[ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "imom")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = imomprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "emom")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = emomprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "zellner")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = zellnerprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
# emom not yet implemented in modelSelection. Also, emomLM won't run with only one x variable.
#
#
if(verbose) cat( "selected :", hppm[[i]], "\n")  # print the HPPM vars
}
}
names_xx_not_selected = setdiff1(names_xx_input_set, unlist(hppm) )
return( list( hppm = unlist(hppm), not.selected = names_xx_not_selected ) )
}
mom = GWASinlps1( y, event, x, family="survival", prior="mom", tau=0.192, priorDelta = modelbbprior(1,1), k0=1, m=50, rxx=0.2, nskip=3, niter=2000, verbose=TRUE, seed=1 )$selected
GWASinlps1 = function( y, event, x, family=c("normal","binomial","survival"), method=c("rigorous","quick"), cor_xy=NULL, mmle_xy=NULL, mu_xy=NULL, prior=c("mom", "imom", "emom", "zellner", "horseshoe"), tau, priorDelta = modelbbprior(1,1), k0, m, rxx, nskip = 3, niter = 2000, verbose = FALSE, seed = NULL, tau.hs.method = "halfCauchy", sigma.hs.method = "Jeffreys" )
{
if(family == "survival")
{
if(!exists("time", mode="integer")) time = Sys.time()
if(!is.null(seed)) set.seed(seed)
# Compute marginal utility if not provided
dat = data.frame(time=y,event=event,x)
if(is.null(mu_xy))
{
mu_xy = c()
for(j in 1:ncol(x)) mu_xy[j] = survreg( formula = as.formula(paste0("Surv(time,event) ~ x",j)), data=dat )$loglik[2]
}
names(mu_xy) = colnames(x)
# Run GWASinlps iteration
varsleft = colnames(x)
selected_iterwise = list()
max_nocollect = 0   # number of times no variables show up in the hppm
iter = 0
lastcollect = ""
while(looprun(lastcollect,varsleft,max_nocollect,m,nskip))
{
# enter ith iteration
iter = iter + 1
if(verbose) cat( "-------------", "\n", "Iteration ", iter, "\n", "-------------", "\n", sep = "")
# run nlpsAFTM
run = nlpsAFTM1( y = log(y), event = event, x = x[ , c(lastcollect[-1],varsleft)], x0 = x[,lastcollect[-1],drop=F], mu_xy=mu_xy, prior = prior, tau = tau, k0 = k0, rxx = rxx, verbose = verbose )
lastcollect = c("",run$hppm)
# add the selected vars to final output & regress them out. if no var is selected, note the instance.
if(length(lastcollect[-1]) > 0)
{
selected_iterwise = c(selected_iterwise, list(lastcollect[-1]))
# varsselected = c(varsselected, lastcollect)  # include HPPM vars in selected set
} else
{
selected_iterwise = c(selected_iterwise, '')
max_nocollect = max_nocollect + 1
if(verbose) {cat("***","nskip=",max_nocollect,"***","\n")}
if(max_nocollect==nskip) break
}
# exclude unselected vars from further consideration
# remove = run$not.selected
# varsleft = setdiff1( varsleft, c(lastcollect,remove) )
varsleft = setdiff1( varsleft, lastcollect[-1] )
# compute conditional utilities (with previously selected vars in model) for the rest of the vars
mu_xy = c()
for(j in 1:length(varsleft)) mu_xy[j] = survreg( formula = as.formula(paste0("Surv(time,event) ~ ", paste0(lastcollect[-1],collapse="+"), "+", varsleft[j])), data=dat )$loglik[2]
mu_xy[mu_xy>0] = min(mu_xy)
names(mu_xy) = varsleft
}
# Final output vars
varsfinal = varsselected[ 2 : min(length(varsselected),m) ]
# Print result
cat("=================================", "\n","Number of selected variables: ", length(varsfinal), "\n", "Time taken: ", round(difftime(Sys.time(), time, units = "mins"),2), " min", "\n",  "=================================", "\n", sep = "")
# Return
return( list(selected=varsfinal, selected_iterwise=selected_iterwise) )
}
}
nlpsAFTM1 = function( y, event, x, x0, mu_xy, prior = c("mom", "imom", "zellner"), tau, priorDelta = modelbbprior(1,1), k0, rxx, niter = 2000, verbose = FALSE )
{
k0 = min(k0,ncol(x)) #if x has only 1 snp, but k0=2, then just reset k0=1
names_sorted_mu_xy = names( sort( mu_xy, decreasing = T ) [1:k0] )  # find x's with top k0 cors
hppm = list()
names_xx_input_set = NULL
for(i in 1:k0)  #take the i'th of top k0 x's
{
corr_xx = c(abs( arma_cor(x, x[,names_sorted_mu_xy[i]]) ))   # find cor of all x vars with xi and give names
names(corr_xx) = colnames(x)
names_xx_thres = na.omit( names(corr_xx[which(corr_xx >= rxx)]) ) # take x's with corr > rxx with xi
names_xx_input =  setdiff1(names_xx_thres, unlist(hppm))  # exclude x's previously chosen in hppm and set the rest as the input x's
names_xx_input_set = c( names_xx_input_set, names_xx_input )  # store the input x's
if(verbose) cat( "j =",i, "\ninput :", c(names_xx_input,colnames(x0)), "\n" )
if(length(names_xx_input) != 0  )  # if there is some input x
{
if(prior == "mom")
{
bb = modelSelection( y = Surv(y, event), x = cbind(x[, names_xx_input, drop=F],x0), family="normal", priorCoef = momprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0))[ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "imom")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = imomprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "emom")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = emomprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "zellner")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = zellnerprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
# emom not yet implemented in modelSelection. Also, emomLM won't run with only one x variable.
#
#
cat( "selected :", hppm[[i]], "\n")  # print the HPPM vars
}
}
names_xx_not_selected = setdiff1(names_xx_input_set, unlist(hppm) )
return( list( hppm = unlist(hppm), not.selected = names_xx_not_selected ) )
}
mom = GWASinlps1( y, event, x, family="survival", prior="mom", tau=0.192, priorDelta = modelbbprior(1,1), k0=1, m=50, rxx=0.2, nskip=3, niter=2000, verbose=TRUE, seed=1 )$selected
GWASinlps1 = function( y, event, x, family=c("normal","binomial","survival"), method=c("rigorous","quick"), cor_xy=NULL, mmle_xy=NULL, mu_xy=NULL, prior=c("mom", "imom", "emom", "zellner", "horseshoe"), tau, priorDelta = modelbbprior(1,1), k0, m, rxx, nskip = 3, niter = 2000, verbose = FALSE, seed = NULL, tau.hs.method = "halfCauchy", sigma.hs.method = "Jeffreys" )
{
if(family == "survival")
{
if(!exists("time", mode="integer")) time = Sys.time()
if(!is.null(seed)) set.seed(seed)
# Compute marginal utility if not provided
dat = data.frame(time=y,event=event,x)
if(is.null(mu_xy))
{
mu_xy = c()
for(j in 1:ncol(x)) mu_xy[j] = survreg( formula = as.formula(paste0("Surv(time,event) ~ x",j)), data=dat )$loglik[2]
}
names(mu_xy) = colnames(x)
# Run GWASinlps iteration
varsleft = colnames(x)
selected_iterwise = list()
max_nocollect = 0   # number of times no variables show up in the hppm
iter = 0
lastcollect = ""
while(looprun(lastcollect,varsleft,max_nocollect,m,nskip))
{
# enter ith iteration
iter = iter + 1
if(verbose) cat( "-------------", "\n", "Iteration ", iter, "\n", "-------------", "\n", sep = "")
# run nlpsAFTM
run = nlpsAFTM1( y = log(y), event = event, x = x[ , c(lastcollect[-1],varsleft)], x0 = x[,lastcollect[-1],drop=F], mu_xy=mu_xy, prior = prior, tau = tau, k0 = k0, rxx = rxx, verbose = verbose )
lastcollect = c("",run$hppm)
# add the selected vars to final output & regress them out. if no var is selected, note the instance.
if(length(lastcollect[-1]) > 0)
{
selected_iterwise = c(selected_iterwise, list(lastcollect[-1]))
# varsselected = c(varsselected, lastcollect)  # include HPPM vars in selected set
} else
{
selected_iterwise = c(selected_iterwise, '')
max_nocollect = max_nocollect + 1
if(verbose) {cat("***","nskip=",max_nocollect,"***","\n")}
if(max_nocollect==nskip) break
}
# exclude unselected vars from further consideration
# remove = run$not.selected
# varsleft = setdiff1( varsleft, c(lastcollect,remove) )
varsleft = setdiff1( varsleft, lastcollect[-1] )
# compute conditional utilities (with previously selected vars in model) for the rest of the vars
mu_xy = c()
for(j in 1:length(varsleft)) mu_xy[j] = survreg( formula = as.formula(paste0("Surv(time,event) ~ ", paste0(lastcollect[-1],collapse="+"), "+", varsleft[j])), data=dat )$loglik[2]
mu_xy[mu_xy>0] = min(mu_xy)
names(mu_xy) = varsleft
}
# Final output vars
varsfinal = varsselected[ 2 : min(length(varsselected),m) ]
# Print result
cat("=================================", "\n","Number of selected variables: ", length(varsfinal), "\n", "Time taken: ", round(difftime(Sys.time(), time, units = "mins"),2), " min", "\n",  "=================================", "\n", sep = "")
# Return
return( list(selected=varsfinal, selected_iterwise=selected_iterwise) )
}
}
nlpsAFTM1 = function( y, event, x, x0, mu_xy, prior = c("mom", "imom", "zellner"), tau, priorDelta = modelbbprior(1,1), k0, rxx, niter = 2000, verbose = FALSE )
{
k0 = min(k0,ncol(x)) #if x has only 1 snp, but k0=2, then just reset k0=1
names_sorted_mu_xy = names( sort( mu_xy, decreasing = T ) [1:k0] )  # find x's with top k0 cors
hppm = list()
names_xx_input_set = NULL
for(i in 1:k0)  #take the i'th of top k0 x's
{
corr_xx = c(abs( arma_cor(x, x[,names_sorted_mu_xy[i]]) ))   # find cor of all x vars with xi and give names
names(corr_xx) = colnames(x)
names_xx_thres = na.omit( names(corr_xx[which(corr_xx >= rxx)]) ) # take x's with corr > rxx with xi
names_xx_input =  setdiff1(names_xx_thres, unlist(hppm))  # exclude x's previously chosen in hppm and set the rest as the input x's
names_xx_input_set = c( names_xx_input_set, names_xx_input )  # store the input x's
if(verbose) cat( "j =",i, "\ninput :", c(names_xx_input,colnames(x0)), "\n" )
if(length(names_xx_input) != 0  )  # if there is some input x
{
if(prior == "mom")
{
bb = modelSelection( y = Surv(y, event), x = cbind(x[, names_xx_input, drop=F],x0), family="normal", priorCoef = momprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0))[ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "imom")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = imomprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "emom")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = emomprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
} else
#
#
if(prior == "zellner")
{
bb = modelSelection( y, x = cbind(x[, names_xx_input, drop=F],x0), priorCoef = zellnerprior(tau=tau), priorDelta = priorDelta, niter = niter, center=T, scale=T, verbose=F )  # NLP-MCMC with those vars only
hppm[[i]] = c(names_xx_input,colnames(x0)) [ which(bb $ postMode == 1) ] # collect the HPPM vars
}
# emom not yet implemented in modelSelection. Also, emomLM won't run with only one x variable.
#
#
if(verbose) cat( "selected :", hppm[[i]], "\n")  # print the HPPM vars
}
}
names_xx_not_selected = setdiff1(names_xx_input_set, unlist(hppm) )
return( list( hppm = unlist(hppm), not.selected = names_xx_not_selected ) )
}
mom = GWASinlps1( y, event, x, family="survival", prior="mom", tau=0.192, priorDelta = modelbbprior(1,1), k0=1, m=50, rxx=0.2, nskip=3, niter=2000, verbose=TRUE, seed=1 )$selected
dev.off()
library(GWASinlps)
?GWASinlps
?mean
library(GWASinlps)
?GWASinlps
library(GWASinlps)
?GWASinlps
n = 200
p = 1000
m = 10
# Generate design matrix (genotype matrix)
set.seed(1)
f = runif( p, .1, .2 ) # simulate minor allele frequency
x = matrix( nrow = n, ncol = p )
colnames(x) = 1:p
for(j in 1:p)
x[,j] = rbinom( n, 2, f[j] )
# Generate true effect sizes
causal_snps = sample( 1:p, m )
beta = rep( 0, p )
set.seed(1)
beta[causal_snps] = rnorm(m, mean = 0, sd = 2 )
# Generate continuous (phenotype) data
y = x %*% beta + rnorm(n, 0, 1)
# Fix scale parameter tau
tau = 0.2
inlps = GWASinlps(y=y, x=x, family="normal", prior="horseshoe", tau=tau, k0=1,
m=50, rxx=0.2)
library(pkgdown)
setwd("/Users/nsanyal/Dropbox/Statistics/Research_Nil/Project-08-GWAS/GWASinlps/R-package/Version_2.2/GWASinlps/")
pkgdown::build_site()
devtools::build_readme()
devtools::build_readme()
devtools::build_readme()
pkgdown::build_home()
